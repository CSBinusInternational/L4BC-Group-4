<!DOCTYPE html>
<html>
<head>
    <title>WASD</title>
    <link rel="stylesheet" type="text/css" href="style.css">
    <script src="babylon.js"></script>
    <script src="hand-1.3.7.js"></script>
    <script src="babylonObjLoader.js"></script>
</head>
<body>
<canvas id="myCanvas"></canvas>
<script>
    var canvas = document.getElementById("myCanvas");
    //defining pointer lock request function
    canvas.requestPointerLock = canvas.requestPointerLock || canvas.mozRequestPointerLock || canvas.webkitRequestPointerLock;
    document.exitPointerLock = document.exitPointerLock || document.mozExitPointerLock || document.webkitExitPointerLock;

    var engine = new BABYLON.Engine(canvas, true);
    var scene = new BABYLON.Scene(engine);

    //setting up initial camera state
    var alfa = 4.71238898038469; //the value of default alpha
    var camera = new BABYLON.ArcRotateCamera("cam1", 0, 0, 0, BABYLON.Vector3.Zero(), scene);
    camera.setPosition(new BABYLON.Vector3(0,1,-5.5));
    camera.attachControl(canvas, false);
    camera.angularSensibilityX = 1000000; //locks camera alpha rotation
    camera.angularSensibilityY = 1000000; //locks camera beta rotation
    camera.lowerBetaLimit = 1.4;
    camera.lowerRadiusLimit = 5.5;
    camera.upperRadiusLimit = 5.5;

    //creating sprite managers for crosshair and click to start sprite
    var spriteManagerClick = new BABYLON.SpriteManager("clickManager", 'Sprite/clicktostart2.png', 1, 1440, scene);
    var spriteManagerAim = new BABYLON.SpriteManager("crosshairManager", 'Sprite/image0014.png', 1, 64, scene);
    spriteManagerAim.isPickable = true;

    //defining a crosshair
    var crosshair = new BABYLON.Sprite("crosshair", spriteManagerAim);
    crosshair.size = 0.6;
    crosshair.isPickable = true;

    //defining click to start
    var click = new BABYLON.Sprite("click", spriteManagerClick);
    click.size = 1;

    //defining function for crosshair placement
    function setCrosshair()
    {
        var degf = model.rotation.y * 180 / Math.PI;
        var degv = camera.beta * 180 / Math.PI;
        modelx = 0.75 * Math.sin((degf-90) * Math.PI / 180) * -1;
        modelz = 0.75 * Math.cos((degf-90) * Math.PI / 180) * -1;
        camy = 3.3 * Math.sin(degv * Math.PI / 180);
        crosshair.position = model.position.add(new BABYLON.Vector3(modelx, camy, modelz));
        if(!isStart) {
            click.position = crosshair.position.add(new BABYLON.Vector3(-0.001, 0, -0.001));
            torus.position = crosshair.position;
        }
    }

    var light = new BABYLON.HemisphericLight('light1', new BABYLON.Vector3(0,10,0), scene);
    light.density = 0.7;

    var ground = BABYLON.Mesh.CreateGround('ground1', 25,25,2, scene);
    var matGround = new BABYLON.StandardMaterial('ground1',scene);
    matGround.diffuseTexture = new BABYLON.Texture('Texture/grass.jpg', scene);
    ground.material = matGround;
    ground.isPickable = false;

    //defining the center of the crosshair
    var torus = BABYLON.MeshBuilder.CreateTorus("torus", {diameter: 0.01, thickness: 0.05}, scene);
    torus.rotation.x = Math.PI/2;

    var model, globalSkele;
    var box = BABYLON.MeshBuilder.CreateBox("box", {size: 3}, scene);

    BABYLON.SceneLoader.ImportMesh("", "Babylon/", "sora.babylon", scene, function(newMeshes, particleSystems, skeletons){
        model = newMeshes[0];
        globalSkele = skeletons[0];
        model.position = new BABYLON.Vector3(0,0,0);
        scene.beginAnimation(globalSkele, 0, 0, false, 1.0);
        model.rotation.y = camera.alpha*-1 - alfa; //to make model facing away from camera

        camera.target = new BABYLON.Vector3(model.position.x, 3, model.position.z);
        box.position = new BABYLON.Vector3(model.position.x, model.position.y+3, model.position.z+10);
        setCrosshair();
    });


    var animationState = false;
    function startAnimation() {
        if(!animationState){
            animationState = true;
            scene.beginAnimation(globalSkele, 1, 20, true, 1.0);
        }
    };

    //defining user control
    var keyCode = {};
    window.onkeydown = function(e) {
        e = e || window.e;
        keyCode[e.keyCode || e.which] = true;

        //defining model rotation based on camera position
        var degf = model.rotation.y * 180 / Math.PI;
        var degl = degf + Math.PI / 2 * 180;
        var degw = degf + Math.PI / 4 * 180;
        var modelxf = 0.05 * Math.sin(degf * Math.PI / 180) * -1;
        var modelzf = 0.05 * Math.cos(degf * Math.PI / 180) * -1;
        var modelxl = 0.05 * Math.sin(degl * Math.PI / 180) * -1;
        var modelzl = 0.05 * Math.cos(degl * Math.PI / 180) * -1;
        var modelxw = 0.05 * Math.sin(degw * Math.PI / 180) * -1;
        var modelzw = 0.05 * Math.cos(degw * Math.PI / 180) * -1;

        if (isStart) {

            if (keyCode[65] && keyCode[87]) {
                console.log("up");
                console.log("left");
                model.position = new BABYLON.Vector3(model.position.x -= modelxw, 0, model.position.z -= modelzw);
            startAnimation();
            }
            else if (keyCode[65] && keyCode[83]) {
                console.log("down");
                console.log("left");
                model.position = new BABYLON.Vector3(model.position.x -= modelxw, 0, model.position.z += modelzw);
            startAnimation();
            }
            else if (keyCode[68] && keyCode[87]) {
                console.log("up");
                console.log("right");
                model.position = new BABYLON.Vector3(model.position.x += modelxw, 0, model.position.z -= modelzw);
            startAnimation();
            }
            else if (keyCode[68] && keyCode[83]) {
                console.log("down");
                console.log("right");
                model.position = new BABYLON.Vector3(model.position.x += modelxw, 0, model.position.z += modelzw);
            startAnimation();
            }
            else if (keyCode[65]) {
                console.log("left");
                model.position = new BABYLON.Vector3(model.position.x += modelxl, 0, model.position.z += modelzl);
                startAnimation();
            }
            else if (keyCode[87]) {
                console.log("up");
                model.position = new BABYLON.Vector3(model.position.x += modelxf, 0, model.position.z += modelzf);
                startAnimation();
            }
            else if (keyCode[83]) {
                console.log("down");
                model.position = new BABYLON.Vector3(model.position.x -= modelxf, 0, model.position.z -= modelzf);
                startAnimation();
            }
            else if (keyCode[68]) {
                console.log("right");
                model.position = new BABYLON.Vector3(model.position.x -= modelxl, 0, model.position.z -= modelzl);
                startAnimation();
            }

            if (keyCode[67]) {
                document.exitPointerLock();
                camera.upperBetaLimit = 1.4;
                model.rotation.y = camera.alpha*-1 - alfa;
                camera.angularSensibilityY = 1000000;
                camera.angularSensibilityX = 1000000;
                isStart = false;
            }

            camera.target = new BABYLON.Vector3(model.position.x, 3, model.position.z);
            setCrosshair();
        }
    }
    
    window.onkeyup = function(e){
        delete keyCode[e.keyCode];
        console.log("keyUp" + e.keyCode);
        if(!keyCode[65]&&!keyCode[87]&&!keyCode[83]&&!keyCode[68]){
            scene.stopAnimation(globalSkele);
            scene.beginAnimation(globalSkele, scene.currentFrame, 0, false, 1.0);
            animationState = false;
        }
    }

    //defining mouse click and unclick function
    var isShooting = false;
    var onPointerUp = function(){
        isShooting = false;
    }
    var onPointerDown = function(){
        isShooting = true;
    }

    canvas.addEventListener("pointerdown", onPointerDown, false);
    canvas.addEventListener("pointerup", onPointerUp, false);

    var isStart = false;
    canvas.addEventListener("click", function(){

        if(isStart == false){
            //defining area for user to click to start
            var pickResult = scene.pick(scene.pointerX, scene.pointerY);
            if(pickResult.hit && pickResult.pickedMesh.name=="torus") {
                    canvas.requestPointerLock();
                    camera.upperBetaLimit = 1.6;
                    isStart = true;
                    //returning camera rotation to default
                    camera.angularSensibilityY = 1000;
                    camera.angularSensibilityX = 1000;
                    //hides click to start
                    click.position = new BABYLON.Vector3(0,100,0);
                    torus.position = new BABYLON.Vector3(0,100,0);
            }
        }
        else {
            var pickResult = scene.pick(scene.pointerX, scene.pointerY);
            if(pickResult.hit) {
                pickResult.pickedMesh.dispose();
                console.log("hit");
            }
            else
                console.log("miss");
        }

//        console.log(pickResult.pickedMesh.name);
    });

    engine.runRenderLoop(function(){

        if(isShooting) {
            console.log("shoot");
        }

        if(camera.alpha!=alfa){
            model.rotation.y = camera.alpha*-1 - alfa;
            setCrosshair();

            console.log(camera.angularSensibilityX);
        }

        scene.render();
    });

    window.addEventListener('resize', function(){
        engine.resize();
    });

    scene.onDispose = function(){
        canvas.removeEventListener("pointerdown", onPointerDown);
        canvas.removeEventListener("pointerup", onPointerUp);
        canvas.removeEventListener("mousemove");
    }
</script>

</body>
</html>