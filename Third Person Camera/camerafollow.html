<!DOCTYPE html>
<html>
<head>
    <title>WASD</title>
    <link rel="stylesheet" type="text/css" href="style.css">
    <script src="babylon.js"></script>
    <script src="hand-1.3.7.js"></script>
    <script src="babylonObjLoader.js"></script>
</head>
<body>
<canvas id="myCanvas"></canvas>
<script>
    var alfa = 4.71238898038469;
    var canvas = document.getElementById("myCanvas");
    var engine = new BABYLON.Engine(canvas, true);
    engine.isPointerLock = true;
    var scene = new BABYLON.Scene(engine);

    var camera = new BABYLON.ArcRotateCamera("cam1", 0, 0, 0, BABYLON.Vector3.Zero(), scene);
    camera.setPosition(new BABYLON.Vector3(0,1,-5.5));
    camera.attachControl(canvas, false);
    camera.lowerBetaLimit = 1.4;
    camera.upperBetaLimit = 1.4;
    camera.lowerRadiusLimit = 5.5;
    camera.upperRadiusLimit = 5.5;
    var spriteManagerAim = new BABYLON.SpriteManager("crosshairManager", 'Sprite/image0014.png', 1, 64, scene);
    var crosshair = new BABYLON.Sprite("crosshair", spriteManagerAim);

    function setCrosshair()
    {
        var degf = model.rotation.y * 180 / Math.PI;
        modelx = 0.05 * Math.sin((degf-15) * Math.PI / 180) * -1;
        modelz = 0.05 * Math.cos((degf-15) * Math.PI / 180) * -1;
//        crosshair.parent = model;
//        crosshair.size = 0.6;
        crosshair.position = model.position.add(new BABYLON.Vector3(modelx*100, 3, modelz*100));
    }
//    CrossHairInFrontOfCamera(YourCrosshairVarNameHere, camera, 1000);

    var light = new BABYLON.HemisphericLight('light1', new BABYLON.Vector3(0,10,0), scene);
    light.density = 0.7;

    var ground = BABYLON.Mesh.CreateGround('ground1', 25,25,2, scene);
    var matGround = new BABYLON.StandardMaterial('ground1',scene);
    matGround.diffuseTexture = new BABYLON.Texture('Texture/grass.jpg', scene);
    ground.material = matGround;

    //camera.lockedTarget = head;
    //camera.radius = 20; // how far from the object to follow
    // camera.heightOffset = 7; // how high above the object to place the camera
    // camera.rotationOffset = 180; // the viewing angle
    // camera.cameraAcceleration = 0.05; // how fast to move
    // camera.maxCameraSpeed = 20; // speed limit
    // scene.activeCamera = camera;
    /* Scene END */

    /* Keyboard Event Start */
    // Global Variable Jump

    var model, globalSkele;

    BABYLON.SceneLoader.ImportMesh("", "Babylon/", "sora.babylon", scene, function(newMeshes, particleSystems, skeletons){
        model = newMeshes[0];
        globalSkele = skeletons[0];
        model.position = new BABYLON.Vector3(0,0,0);
        scene.beginAnimation(globalSkele, 0, 0, false, 1.0);
        model.rotation.y = camera.alpha*-1 - alfa;
        camera.target = new BABYLON.Vector3(model.position.x, 3, model.position.z);
//        var degf = model.rotation.y * 180 / Math.PI;
//        modelx = 0.05 * Math.sin((degf-15) * Math.PI / 180) * -1;
//        modelz = 0.05 * Math.cos((degf-15) * Math.PI / 180) * -1;
        crosshair.parent = model;
        crosshair.size = 0.6;
//        crosshair.position = model.position.add(new BABYLON.Vector3(modelx*100, 3, modelz*100));
        setCrosshair();
    });

    var animationState = false;
    function startAnimation() {
        if(!animationState){
            animationState = true;
            scene.beginAnimation(globalSkele, 1, 20, true, 1.0);
        }
    };

    var keyCode = {}, isShooting = false;

    window.onkeydown = function(e){
        e = e || window.e;
        keyCode[e.keyCode || e.which ] = true;

//        var degf = model.rotation.y * 180 / Math.PI;
//        modelx = 0.05 * Math.sin((degf-15) * Math.PI / 180) * -1;
//        modelz = 0.05 * Math.cos((degf-15) * Math.PI / 180) * -1;
//        crosshair.position = model.position.add(new BABYLON.Vector3(modelx*100, 3, modelz*100));
        setCrosshair();
        var degf = model.rotation.y * 180 / Math.PI;
        var degl = degf + Math.PI/2 * 180;
        var modelx, modelz;

        if(keyCode[65]){
            console.log("left");
            modelx = 0.05 * Math.sin(degl * Math.PI / 180) * -1;
            modelz = 0.05 * Math.cos(degl * Math.PI / 180) * -1;
            model.position = new BABYLON.Vector3(model.position.x+=modelx,0,model.position.z+=modelz);
            startAnimation();
        }
        if(keyCode[87]){
            console.log("up");
            modelx = 0.05 * Math.sin(degf * Math.PI / 180) * -1;
            modelz = 0.05 * Math.cos(degf * Math.PI / 180) * -1;
            model.position = new BABYLON.Vector3(model.position.x+=modelx,0,model.position.z+=modelz);
            startAnimation();
        }
        if(keyCode[83]){
            console.log("down");
            modelx = -0.05 * Math.sin(degf * Math.PI / 180) * -1;
            modelz = -0.05 * Math.cos(degf * Math.PI / 180) * -1;
            model.position = new BABYLON.Vector3(model.position.x+=modelx,0,model.position.z+=modelz);
            startAnimation();
        }
        if(keyCode[68]){
            console.log("right");
            modelx = -0.05 * Math.sin(degl * Math.PI / 180) * -1;
            modelz = -0.05 * Math.cos(degl * Math.PI / 180) * -1;
            model.position = new BABYLON.Vector3(model.position.x+=modelx,0,model.position.z+=modelz);
            startAnimation();
        }
        if(keyCode[67]){
            if(engine.isPointerLock)
                engine.isPointerLock = false;
            else
                engine.isPointerLock = true;
        }

//        dummy.position = new BABYLON.Vector3(model.position.x, 3.5, model.position.z);
//        dummy.position.add(0,3.5,0);
        camera.target = new BABYLON.Vector3(model.position.x, 3, model.position.z);
    }

        window.onkeyup = function(e){
            delete keyCode[e.keyCode];
            if(!keyCode[65]&&!keyCode[87]&&!keyCode[83]&&!keyCode[68]) {
                scene.stopAnimation(globalSkele);
                scene.beginAnimation(globalSkele, scene.currentFrame, 0, false, 1.0);
                animationState = false;
            }
        }

//    window.onkeydown = function(event){
//        event = event || window.event;
//        var keyCodeDown = event.which || event.keyCode;
//
//        switch(keyCodeDown) {
//            // W
//            case 87:
//                forward = true;
//                startAnimation();
//                break;
//
//            // A
//            case 65:
//                left = true;
//                startAnimation();
//                break;
//
//            // S
//            case 83:
//                back = true;
//                startAnimation();
//                break;
//
//            // D
//            case 68:
//                right = true;
//                startAnimation();
//                break;
//        }
//    };
//    var flagg = false;
//
//
//    window.onkeyup = function(event) {
//        event = event || window.event;
//        var keyCodeUp = event.which || event.keyCode;
//
//        switch (keyCodeUp) {
//            // W
//            case 87:
//                forward = false;
//                scene.stopAnimation(globalSkele);
//                scene.beginAnimation(globalSkele, scene.currentFrame, 0, false, 1.0);
//                animationState = false;
//                break;
//
//            // A
//            case 65:
//                left = false;
//                scene.stopAnimation(globalSkele);
//                scene.beginAnimation(globalSkele, scene.currentFrame, 0, false, 1.0);
//                animationState = false;
//                break;
//
//            // S
//            case 83:
//                back = false;
//                scene.stopAnimation(globalSkele);
//                scene.beginAnimation(globalSkele, scene.currentFrame, 0, false, 1.0);
//                animationState = false;
//                break;
//
//            // D
//            case 68:
//                right = false;
//                scene.stopAnimation(globalSkele);
//                scene.beginAnimation(globalSkele, scene.currentFrame, 0, false, 1.0);
//                animationState = false;
//                break;
//
//            default:
//                animationState = false;
//                break;
//
//        }
//
//    };
    /* Keyboard Event End */

    var onPointerUp = function(){
        isShooting = false;
    }

    var onPointerDown = function(){
        isShooting = true;
    }

    canvas.addEventListener("pointerdown", onPointerDown, false);
    canvas.addEventListener("pointerup", onPointerUp, false);
    canvas.addEventListener("mousemove", function(){

    });

    engine.runRenderLoop(function(){

        if(isShooting)
            console.log("shoot");

        if(camera.alpha!=alfa){
            model.rotation.y = camera.alpha*-1 - alfa;
//            var degf = model.rotation.y * 180 / Math.PI;
//            modelx = 0.05 * Math.sin((degf-15) * Math.PI / 180) * -1;
//            modelz = 0.05 * Math.cos((degf-15) * Math.PI / 180) * -1;
//            crosshair.position = model.position.add(new BABYLON.Vector3(modelx*100, 3, modelz*100));
            setCrosshair();
            console.log(camera.alpha);
        }
        scene.render();
    });

    window.addEventListener('resize', function(){
        engine.resize();
    });

    scene.onDispose = function(){
        canvas.removeEventListener("pointerdown", onPointerDown);
        canvas.removeEventListener("pointerup", onPointerUp);
    }
</script>

</body>
</html>