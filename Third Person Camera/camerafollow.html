<!DOCTYPE html>
<html>
<head>
    <title>WASD</title>
    <link rel="stylesheet" type="text/css" href="style.css">
    <script src="babylon.js"></script>
    <script src="hand-1.3.7.js"></script>
    <script src="babylonObjLoader.js"></script>
</head>
<body>
<canvas id="myCanvas"></canvas>
<script>
    var alfa = 4.71238898038469;
    var canvas = document.getElementById("myCanvas");
    canvas.requestPointerLock = canvas.requestPointerLock || canvas.mozRequestPointerLock || canvas.webkitRequestPointerLock;
    document.exitPointerLock = document.exitPointerLock || document.mozExitPointerLock || document.webkitExitPointerLock;
    var engine = new BABYLON.Engine(canvas, true);
    var scene = new BABYLON.Scene(engine);

    var camera = new BABYLON.ArcRotateCamera("cam1", 0, 0, 0, BABYLON.Vector3.Zero(), scene);
    camera.setPosition(new BABYLON.Vector3(0,1,-5.5));
    camera.attachControl(canvas, false);
    camera.angularSensibilityX = 1000000;
    camera.angularSensibilityY = 1000000;
    camera.lowerBetaLimit = 1.4;
    camera.upperBetaLimit = 1.6;
    camera.lowerRadiusLimit = 5.5;
    camera.upperRadiusLimit = 5.5;
    var spriteManagerClick = new BABYLON.SpriteManager("clickManager", 'Sprite/tapheretostart.png', 1, 512, scene);
    var spriteManagerAim = new BABYLON.SpriteManager("crosshairManager", 'Sprite/image0014.png', 1, 64, scene);
    spriteManagerAim.isPickable = true;
    var crosshair = new BABYLON.Sprite("crosshair", spriteManagerAim);
    crosshair.isPickable = true;
    var click = new BABYLON.Sprite("click", spriteManagerClick);
    click.size = 0.3;

    function setCrosshair()
    {
        var degf = model.rotation.y * 180 / Math.PI;
        var degv = camera.beta * 180 / Math.PI;
        modelx = 0.75 * Math.sin((degf-90) * Math.PI / 180) * -1;
        modelz = 0.75 * Math.cos((degf-90) * Math.PI / 180) * -1;
        camy = 3.3 * Math.sin(degv * Math.PI / 180);
        crosshair.position = model.position.add(new BABYLON.Vector3(modelx, camy, modelz));
        if(!isStart)
            click.position = model.position.add(new BABYLON.Vector3(modelx-0.075, camy-0.07, modelz-0.075));
    }

    var light = new BABYLON.HemisphericLight('light1', new BABYLON.Vector3(0,10,0), scene);
    light.density = 0.7;

    var ground = BABYLON.Mesh.CreateGround('ground1', 25,25,2, scene);
    var matGround = new BABYLON.StandardMaterial('ground1',scene);
    matGround.diffuseTexture = new BABYLON.Texture('Texture/grass.jpg', scene);
    ground.material = matGround;
    ground.isPickable = false;

    var model, globalSkele;
    var d = BABYLON.MeshBuilder.CreateBox("box", {size: 3}, scene);

    BABYLON.SceneLoader.ImportMesh("", "Babylon/", "sora.babylon", scene, function(newMeshes, particleSystems, skeletons){
        model = newMeshes[0];
        globalSkele = skeletons[0];
        model.position = new BABYLON.Vector3(0,0,0);
        scene.beginAnimation(globalSkele, 0, 0, false, 1.0);
        model.rotation.y = camera.alpha*-1 - alfa;
        camera.target = new BABYLON.Vector3(model.position.x, 3, model.position.z);
        crosshair.parent = model;
        crosshair.size = 0.6;
        d.position = new BABYLON.Vector3(model.position.x, model.position.y+3, model.position.z+10);
        setCrosshair();
    });


    var animationState = false;
    function startAnimation() {
        if(!animationState){
            animationState = true;
            scene.beginAnimation(globalSkele, 1, 20, true, 1.0);
        }
    };

    var keyCode = {}, isShooting = false;

    window.onkeydown = function(e) {
        e = e || window.e;
        keyCode[e.keyCode || e.which] = true;

        var degf = model.rotation.y * 180 / Math.PI;
        var degl = degf + Math.PI / 2 * 180;
        var degw = degf + Math.PI / 4 * 180;
        var modelxf = 0.05 * Math.sin(degf * Math.PI / 180) * -1;
        var modelzf = 0.05 * Math.cos(degf * Math.PI / 180) * -1;
        var modelxl = 0.05 * Math.sin(degl * Math.PI / 180) * -1;
        var modelzl = 0.05 * Math.cos(degl * Math.PI / 180) * -1;
        var modelxw = 0.05 * Math.sin(degw * Math.PI / 180) * -1;
        var modelzw = 0.05 * Math.cos(degw * Math.PI / 180) * -1;

        if (isStart) {
            if ((keyCode[65] && keyCode[87]) || (keyCode[65] && keyCode[83]) || (keyCode[68] && keyCode[87]) || (keyCode[68] && keyCode[83])) {

                if (keyCode[65] && keyCode[87]) {
                    console.log("upleft");
                    model.position = new BABYLON.Vector3(model.position.x -= modelxw, 0, model.position.z -= modelzw);
                    //                startAnimation();
                }
                else if (keyCode[65] && keyCode[83]) {
                    console.log("downleft");
                    model.position = new BABYLON.Vector3(model.position.x -= modelxw, 0, model.position.z += modelzw);
                    //                startAnimation();
                }
                else if (keyCode[68] && keyCode[87]) {
                    console.log("upright");
                    model.position = new BABYLON.Vector3(model.position.x += modelxw, 0, model.position.z -= modelzw);
                    //                startAnimation();
                }
                else if (keyCode[68] && keyCode[83]) {
                    console.log("downleft");
                    model.position = new BABYLON.Vector3(model.position.x += modelxw, 0, model.position.z += modelzw);
                    //                startAnimation();
                }
            }
            else if (keyCode[65]) {
                console.log("left");
                model.position = new BABYLON.Vector3(model.position.x += modelxl, 0, model.position.z += modelzl);
                startAnimation();
            }
            else if (keyCode[87]) {
                console.log("up");
                model.position = new BABYLON.Vector3(model.position.x += modelxf, 0, model.position.z += modelzf);
                startAnimation();
            }
            else if (keyCode[83]) {
                console.log("down");
                model.position = new BABYLON.Vector3(model.position.x -= modelxf, 0, model.position.z -= modelzf);
                startAnimation();
            }
            else if (keyCode[68]) {
                console.log("right");
                model.position = new BABYLON.Vector3(model.position.x -= modelxl, 0, model.position.z -= modelzl);
                startAnimation();
            }

            if (keyCode[67]) {
                document.exitPointerLock();
                camera.angularSensibilityY = 1000000;
                camera.angularSensibilityX = 1000000;
                isStart = false;
            }

            camera.target = new BABYLON.Vector3(model.position.x, 3, model.position.z);
            setCrosshair();
        }
    }
        window.onkeyup = function(e){
            delete keyCode[e.keyCode];
//            if(!keyCode[65]&&!keyCode[87]&&!keyCode[83]&&!keyCode[68]) {
            if((e.keyCode==65||e.keyCode==87||e.keyCode==83||e.keyCode==68)||(!keyCode[65]&&!keyCode[87]&&!keyCode[83]&&!keyCode[68])){
                scene.stopAnimation(globalSkele);
                scene.beginAnimation(globalSkele, scene.currentFrame, 0, false, 1.0);
                animationState = false;
            }
        }


    var onPointerUp = function(){
        isShooting = false;
    }

    var onPointerDown = function(){
        isShooting = true;
    }

    canvas.addEventListener("pointerdown", onPointerDown, false);
    canvas.addEventListener("pointerup", onPointerUp, false);
    canvas.addEventListener("mousemove", function(){

    });

    var isStart = false;
    canvas.addEventListener("click", function(){

        if(isStart == false){
            var pickResult = scene.pickSprite(scene.pointerX, scene.pointerY);
            if(pickResult.hit) {
//                console.log(scene.pointerX);
//                console.log(scene.pointerY);
                if(parseInt((scene.pointerX-4)/10) == 62 && parseInt(scene.pointerY/10) == 38) {
                    canvas.requestPointerLock();
                    isStart = true;
                    camera.angularSensibilityY = 1000;
                    camera.angularSensibilityX = 1000;
                    click.position = model.position.add(new BABYLON.Vector3(modelx-0.075, camy-10, modelz-0.075));
                }
            }
        }
        else {
            click = new BABYLON.Sprite("click", spriteManagerClick);
            click.size = 0.3;
            var pickResult = scene.pick(scene.pointerX, scene.pointerY);
            if(pickResult.hit) {
                pickResult.pickedMesh.dispose();
                console.log("hit");
            }
            else
                console.log("miss");
        }

        console.log(pickResult.pickedMesh.name);
    });

    engine.runRenderLoop(function(){

        if(isShooting) {
            console.log("shoot");
        }

        if(camera.alpha!=alfa){
            model.rotation.y = camera.alpha*-1 - alfa;
            setCrosshair();

            console.log(camera.angularSensibilityX);
        }

        scene.render();
    });

    window.addEventListener('resize', function(){
        engine.resize();
    });

    scene.onDispose = function(){
        canvas.removeEventListener("pointerdown", onPointerDown);
        canvas.removeEventListener("pointerup", onPointerUp);
        canvas.removeEventListener("mousemove");
    }
</script>

</body>
</html>