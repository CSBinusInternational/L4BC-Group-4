<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Gangster Shooting</title>
    <link rel="stylesheet" type="text/css" href="Common/style.css">
    <script src="Common/babylon.js"></script>
    <script src="Common/hand-1.3.7.js"></script>
    <script src="Common/babylonObjLoader.js"></script>
    <script src="src/GUIManager.js"></script>
    <script src="src/GUIGroup.js"></script>
    <script src="src/GUIPanel.js"></script>
    <script src="src/GUITexture.js"></script>
    <script src="src/GUIText.js"></script>
    <script src="src/GUITextfield.js"></script>
    <script src="src/GUITextarea.js"></script>
    <script src="src/GUISelect.js"></script>
    <script src="src/GUIWindow.js"></script>
    <script src="src/GUIButton.js"></script>
    <script src="src/GUINativeColor.js"></script>
    <script src="src/GUIColor.js"></script>
    <script src="src/GUICheckbox.js"></script>
    <script src="src/GUIFieldset.js"></script>
    <script src="src/GUILabel.js"></script>
    <script src="src/GUIRadio.js"></script>
    <script src="src/GUISlider.js"></script>
    <script src="src/GUIDialog.js"></script>
    <script src="src/GUIProgress.js"></script>
    <script src="src/GUIMeter.js"></script>
    <script src="src/GUISpinner.js"></script>
    <script src="src/draggableGUI.js"></script>
</head>
<body>
    <canvas id="myCanvas"></canvas>
    <script>
        var canvas = document.getElementById("myCanvas");
        var engine = new BABYLON.Engine(canvas, true);
        var scene = new BABYLON.Scene(engine);

        // Defining pointer lock request function
        canvas.requestPointerLock = canvas.requestPointerLock || canvas.mozRequestPointerLock || canvas.webkitRequestPointerLock;
        document.exitPointerLock = document.exitPointerLock || document.mozExitPointerLock || document.webkitExitPointerLock;
        // End of defining pointer lock request function

        // Sound effect
        var wilhelm = new BABYLON.Sound("wilhelm", "Soundtrack/wilhelm.mp3", scene, null);
        // End of sound effect

        // Setting up initial camera state
            var alfa = 4.71238898038469; //the value of default alpha
            var camera = new BABYLON.ArcRotateCamera("cam1", 0, 0, 0, BABYLON.Vector3.Zero(), scene);
            camera.setPosition(new BABYLON.Vector3(0,1,-5.5));
            camera.attachControl(canvas, false);
            camera.angularSensibilityX = 1000000; //locks camera alpha rotation
            camera.angularSensibilityY = 1000000; //locks camera beta rotation
            camera.lowerBetaLimit = 1.4;
            camera.lowerRadiusLimit = 5.5;
            camera.upperRadiusLimit = 5.5;
        // End of setting up camera state
        
        var css = "button{cursor:pointer;}";
        CASTORGUI.GUIManager.convertPixelToPercent = true;
        guisystem = new CASTORGUI.GUIManager(canvas, css, {themeRoot: "dist/", pixel: false});

        var canvas2d =  new BABYLON.ScreenSpaceCanvas2D(scene,{
            id: "MenuCanvas",
            size: new BABYLON.Size(guisystem.getCanvasSize().width, guisystem.getCanvasSize().height),
            backgroundFill: "#000000FF",
            children: [
                new BABYLON.Text2D("Welcome to our Game", {
                    id: "text",
                    marginAlignment: "h: center, v: top",
                    fontName: "90pt Arial",
                    fontSuperSample : true,
                })
            ]

        });

        var buttonStart = new BABYLON.Rectangle2D({
            parent: canvas2d,
            id: "button",
            x: guisystem.getCanvasSize().width/2,
            y: guisystem.getCanvasSize().height/2,
            width:200,
            height:100,
            fill: "#40C040FF",
            roundRadius : 1,
            children: [
                new BABYLON.Text2D("Start Game!", {
                    id: "startText",
                    fontName : "20pt Arial",
                    marginAlignment: "h:center, v:center",
                    fontSuperSample: true
                })
            ]
        });

        buttonStart.pointerEventObservable.add(function(){
            canvas2d.dispose();
        }, BABYLON.PrimitivePointerInfo.PointerDown);

        // Creating sprite managers for crosshair and click to start sprite
        var spriteManagerClick = new BABYLON.SpriteManager("clickManager", 'Object/Sprite/clicktostart2.png', 1, 1440, scene);
        var spriteManagerAim = new BABYLON.SpriteManager("crosshairManager", 'Object/Sprite/image0014.png', 1, 64, scene);
        spriteManagerAim.isPickable = true;
        // End of creating sprite managers

        // Defining a crosshair
        var crosshair = new BABYLON.Sprite("crosshair", spriteManagerAim);
        crosshair.size = 0.6;
        crosshair.isPickable = true;
        // End of defining a crosshair

        // Defining the center of the crosshair
        var torus = BABYLON.MeshBuilder.CreateTorus("torus", {diameter: 0.01, thickness: 0.05}, scene);
        torus.rotation.x = Math.PI/2;
        // End of defining center of the crosshair

        // Defining click to start
        var click = new BABYLON.Sprite("click", spriteManagerClick);
        // End of defining click to start

        // Lighting
        var light = new BABYLON.HemisphericLight('light1', new BABYLON.Vector3(0,100,0), scene);
        light.density = 0.7;
        light.specular = new BABYLON.Color3(0,0,0);
        // End of Lighting

        // SkyBox
        var skybox = BABYLON.MeshBuilder.CreateBox("skyBox", {size:1000.0}, scene);
        var skyboxMaterial = new BABYLON.StandardMaterial("skyBox", scene);
        skyboxMaterial.backFaceCulling = false;
        skyboxMaterial.reflectionTexture = new BABYLON.CubeTexture("Texture/sunnyDay", scene);
        skyboxMaterial.reflectionTexture.coordinatesMode = BABYLON.Texture.SKYBOX_MODE;
        skyboxMaterial.diffuseColor = new BABYLON.Color3(0, 0, 0);
        skyboxMaterial.specularColor = new BABYLON.Color3(0, 0, 0);
        skybox.material = skyboxMaterial;
        // End of SkyBox

        // Terrain
        BABYLON.SceneLoader.ImportMesh("","Object/Terrain/", "terrain2-texture.babylon", scene, function (newMeshes, particleSystems) {
            var terrain = newMeshes[0];
            terrain.position = new BABYLON.Vector3(0, 0, 0);
            terrain.scaling = new BABYLON.Vector3(400, 400, 400);
        });
        // End of Terrain

        // Player
        var player, playerSkeleton;
        BABYLON.SceneLoader.ImportMesh("", "Object/Player/", "sora.babylon", scene, function(newMeshes, particleSystems, skeletons){
            player = newMeshes[0];
            playerSkeleton = skeletons[0];
            player.position = new BABYLON.Vector3(-25,0,0);
            scene.beginAnimation(playerSkeleton, 0, 0, false, 1.0);
            player.rotation.y = camera.alpha*-1 - alfa; //to make player facing away from camera

            camera.target = new BABYLON.Vector3(player.position.x, 3, player.position.z);
            setCrosshair();
        });
        // End of Player

        // House
        var house;
        BABYLON.SceneLoader.ImportMesh("", "Object/House/", "house2.babylon", scene, function(newMeshes){
            house = newMeshes[0];
            house.position = new BABYLON.Vector3(0,0,0);
            var houseTexture = new BABYLON.StandardMaterial("houseTex", scene);
            houseTexture.diffuseTexture = new BABYLON.Texture("Object/House/Farmhouse Texture.jpg", scene);
            house.material = houseTexture;
            house.scaling = new BABYLON.Vector3(0.7, 0.7, 0.7);
            house.rotation.y = Math.PI/2;
        });
        // End of House

        // Health Bar
        var guiTextureLost_0 = new CASTORGUI.GUITexture("lost0", "Object/HUD/grey.jpg", {w:50,h:50,x:10,y:10}, guisystem, null);
        var guiTextureLost_25 = new CASTORGUI.GUITexture("lost25", "Object/HUD/grey.jpg", {w:50,h:50,x:60,y:10}, guisystem, null);
        var guiTextureLost_50 = new CASTORGUI.GUITexture("lost50", "Object/HUD/grey.jpg", {w:50,h:50,x:110,y:10}, guisystem, null);
        var guiTextureLost_75 = new CASTORGUI.GUITexture("lost75", "Object/HUD/grey.jpg", {w:50,h:50,x:160,y:10}, guisystem, null);
        var guiTextureLost_100 = new CASTORGUI.GUITexture("lost100", "Object/HUD/grey.jpg", {w:50,h:50,x:210,y:10}, guisystem, null);

        var guiTextureLife_0 = new CASTORGUI.GUITexture("life0", "Object/HUD/red.jpg", {w:50,h:50,x:10,y:10}, guisystem, null);
        var guiTextureLife_25 = new CASTORGUI.GUITexture("life25", "Object/HUD/red.jpg", {w:50,h:50,x:60,y:10}, guisystem, null);
        var guiTextureLife_50 = new CASTORGUI.GUITexture("life50", "Object/HUD/red.jpg", {w:50,h:50,x:110,y:10}, guisystem, null);
        var guiTextureLife_75 = new CASTORGUI.GUITexture("life75", "Object/HUD/red.jpg", {w:50,h:50,x:160,y:10}, guisystem, null);
        var guiTextureLife_100 = new CASTORGUI.GUITexture("life100", "Object/HUD/red.jpg", {w:50,h:50,x:210,y:10}, guisystem, null);

        var groupLife = new CASTORGUI.GUIGroup("groupLife", null, guisystem);
        groupLife.add(guiTextureLife_0);
        groupLife.add(guiTextureLife_25);
        groupLife.add(guiTextureLife_50);
        groupLife.add(guiTextureLife_75);
        groupLife.add(guiTextureLife_100);

        var groupLost = new CASTORGUI.GUIGroup("groupLost", null, guisystem);
        groupLost.add(guiTextureLost_0);
        groupLost.add(guiTextureLost_25);
        groupLost.add(guiTextureLost_50);
        groupLost.add(guiTextureLost_75);
        groupLost.add(guiTextureLost_100);
        // End of Health bar

        // Total Bullets


        // End of Total Bullets
        
        // Key Event
        // To set when the animation of the player should play
        var animationState = false;
        function startAnimation() {
            if(!animationState){
                animationState = true;
                scene.beginAnimation(playerSkeleton, 1, 20, true, 1.0);
            }
        };

        // Defining user control of keyboard
        var keyCode = {};
        window.onkeydown = function(e) {
            e = e || window.e;
            keyCode[e.keyCode || e.which] = true;

            // Defining player rotation based on camera position
            var degf = player.rotation.y * 180 / Math.PI;
            var degl = degf + Math.PI / 2 * 180;
            var degw = degf + Math.PI / 4 * 180;
            var degv = degf - Math.PI / 4 * 180;
            var speed = 0.2;
            var playerxf = speed * Math.sin(degf * Math.PI / 180) * -1;
            var playerzf = speed * Math.cos(degf * Math.PI / 180) * -1;
            var playerxl = speed * Math.sin(degl * Math.PI / 180) * -1;
            var playerzl = speed * Math.cos(degl * Math.PI / 180) * -1;
            var playerxw = speed * Math.sin(degw * Math.PI / 180) * -1;
            var playerzw = speed * Math.cos(degw * Math.PI / 180) * -1;
            var playerxv = speed * Math.sin(degv * Math.PI / 180) * -1;
            var playerzv = speed * Math.cos(degv * Math.PI / 180) * -1;

            if (isStart) {
                if ((keyCode[65] && keyCode[87]) || (keyCode[65] && keyCode[83]) || (keyCode[68] && keyCode[87]) || (keyCode[68] && keyCode[83])) {

                    if (keyCode[65] && keyCode[87]) {
                        console.log("upleft");
                        player.position = new BABYLON.Vector3(player.position.x -= playerxw, 0, player.position.z -= playerzw);
                        startAnimation();
                    }
                    else if (keyCode[65] && keyCode[83]) {
                        console.log("downleft");
                        player.position = new BABYLON.Vector3(player.position.x += playerxv, 0, player.position.z += playerzv);
                        startAnimation();
                    }
                    else if (keyCode[68] && keyCode[87]) {
                        console.log("upright");
                        player.position = new BABYLON.Vector3(player.position.x -= playerxv, 0, player.position.z -= playerzv);
                        startAnimation();
                    }
                    else if (keyCode[68] && keyCode[83]) {
                        console.log("downright");
                        player.position = new BABYLON.Vector3(player.position.x += playerxw, 0, player.position.z += playerzw);
                        startAnimation();
                    }
                }
                else if (keyCode[65]) {
                    console.log("left");
                    player.position = new BABYLON.Vector3(player.position.x += playerxl, 0, player.position.z += playerzl);
                    startAnimation();
                }
                else if (keyCode[87]) {
                    console.log("up");
                    player.position = new BABYLON.Vector3(player.position.x += playerxf, 0, player.position.z += playerzf);
                    startAnimation();
                }
                else if (keyCode[83]) {
                    console.log("down");
                    player.position = new BABYLON.Vector3(player.position.x -= playerxf, 0, player.position.z -= playerzf);
                    startAnimation();
                }
                else if (keyCode[68]) {
                    console.log("right");
                    player.position = new BABYLON.Vector3(player.position.x -= playerxl, 0, player.position.z -= playerzl);
                    startAnimation();
                }

                if (keyCode[67]) {
                    document.exitPointerLock();
                    camera.angularSensibilityY = 1000000;
                    camera.angularSensibilityX = 1000000;
                    camera.upperBetaLimit = 1.4;
                    player.rotation.y = camera.alpha*-1 - alfa;
                    isStart = false;
                }

                camera.target = new BABYLON.Vector3(player.position.x, 3, player.position.z);
                setCrosshair();
            }
        }
        
        window.onkeyup = function(e){
            delete keyCode[e.keyCode];
            if(!keyCode[65]&&!keyCode[87]&&!keyCode[83]&&!keyCode[68]){
                scene.stopAnimation(playerSkeleton);
                scene.beginAnimation(playerSkeleton, scene.currentFrame, 0, false, 1.0);
                animationState = false;
            }
        }

        // Defining user input from mouse
        // Defining mouse click and unclick function
        var isShooting = false;
        var onPointerUp = function(){
            isShooting = false;
        }

        var onPointerDown = function(){
            isShooting = true;
        }

        canvas.addEventListener("pointerdown", onPointerDown, false);
        canvas.addEventListener("pointerup", onPointerUp, false);

        var isStart = false;
        canvas.addEventListener("click", function(){

            if(isStart == false){
                //defining area for user to click to start
                var pickResult = scene.pick(scene.pointerX, scene.pointerY);
                if(pickResult.hit && pickResult.pickedMesh.name=="torus") {
                        canvas.requestPointerLock();
                        camera.upperBetaLimit = 1.6;
                        isStart = true;

                        //returning camera rotation to default
                        camera.angularSensibilityY = 5000;
                        camera.angularSensibilityX = 5000;

                        //hides click to start
                        click.position = new BABYLON.Vector3(0,100,0);
                        torus.position = new BABYLON.Vector3(0,100,0);
                }
            }
            else {
                var pickResult = scene.pick(scene.pointerX, scene.pointerY);
                if(pickResult.hit) {
                    var meshName = pickResult.pickedMesh.name;
                    if(meshName.includes("zombie")){
                        pickResult.pickedMesh.dispose();
                        console.log("hit");
                    }
                }
                else
                    console.log("miss");
            }
        });
        // End of key event

        // Rendering Scene
        var time = 0, health = 4;
        var i = 1;
        engine.runRenderLoop(function(){

            // To generate the zombie for every 4 seconds
            if(time % 360 == 0){

                // To random the position of the zombie. 
                // Whether at the north, south, east or west side of the terrain
                // 1 = north, 2 = south, 3 = east, 4 = west
                var position = Math.floor(Math.random()*4) + 1;

                if(position == 1){
                    // Import the zombie to the specified area on the north
                    importZombie(position, i);
                }
                else if(position == 2){
                    // Import the zombie to the specified area on the south
                    importZombie(position, i);
                }
                else if(position == 3){
                    // Import the zombie to the specified area on the east
                    importZombie(position, i);
                }
                else{
                    // Import the zombie to the specified area on the west
                    importZombie(position, i);
                }
                i++;
            }

            // To move the zombie based on their position
            for(var a=1; a<=i; a++){
                var zombie = scene.getMeshByName("zombie"+a);
                if(zombie){

                    // if from the north area
                    if(zombie.matchesTagsQuery("north"))
                        zombie.position.z -= 0.05;

                    // if from the south area
                    else if(zombie.matchesTagsQuery("south"))
                        zombie.position.z += 0.05;

                    // if from the east area
                    else if(zombie.matchesTagsQuery("east"))
                        zombie.position.x -= 0.05;

                    // if from the west area
                    else if(zombie.matchesTagsQuery("west"))
                        zombie.position.x += 0.05;
                }    
            }
            time++;

            if(camera.alpha!=alfa){
                player.rotation.y = camera.alpha*-1 - alfa;
                setCrosshair();
            }

            scene.render();
        });

        window.addEventListener('resize', function(){
            engine.resize();
        });

        // Function to import the zombies 
        function importZombie(position, i){
            BABYLON.SceneLoader.ImportMesh("", "Object/Zombie/", "zombie.babylon", scene, function(newMeshes, particleSystems, skeletons){
                var mesh = newMeshes[0];
                var playerSkeleton = skeletons[0];

                // Zombi respawn area (x, y, z)
                // North : -10 -- 10, 0,  140 --  160
                // South : -10 -- 10, 0, -160 -- -140
                // East  :  120 -- 130, 0, -6 -- 6
                // West  : -160 -- -150, 0, -6 -- 6

                if(position == 1){
                    mesh.position = new BABYLON.Vector3(Math.floor(Math.random() * 20) - 10, 0, Math.floor(Math.random() * 20) + 140);
                    BABYLON.Tags.AddTagsTo(mesh, "north");
                }
                else if(position == 2){
                    mesh.position = new BABYLON.Vector3(Math.floor(Math.random() * 20) - 10, 0, Math.floor(Math.random() * 20) - 160);
                    BABYLON.Tags.AddTagsTo(mesh, "south");
                    mesh.rotation = new BABYLON.Vector3(0, Math.PI, 0);
                }
                else if(position == 3){
                    mesh.position = new BABYLON.Vector3(Math.floor(Math.random() * 10) + 120, 0, Math.floor(Math.random() * 12) - 6);
                    BABYLON.Tags.AddTagsTo(mesh, "east");
                    mesh.rotation = new BABYLON.Vector3(0, Math.PI/2, 0);
                }
                else{
                    mesh.position = new BABYLON.Vector3(Math.floor(Math.random() * 10) - 160, 0, Math.floor(Math.random() * 12) - 6);
                    BABYLON.Tags.AddTagsTo(mesh, "west");
                    mesh.rotation = new BABYLON.Vector3(0, Math.PI/2 * 3, 0);
                }

                // Give names to the Zombie mesh to access it later
                mesh.name = "zombie" + i;
                mesh.scaling = new BABYLON.Vector3(2.5, 2.5, 2.5);

                // Starting the animation of the zombie
                scene.beginAnimation(playerSkeleton, 1, 60, true, 1.0);
                
                // Applying action manager to the zombies so that they will do something
                // when they hit the house
                mesh.actionManager = new BABYLON.ActionManager(scene);
                mesh.actionManager.registerAction(new BABYLON.ExecuteCodeAction( { trigger: BABYLON.ActionManager.OnIntersectionEnterTrigger, parameter: house }, function(){
                    hitted();
                    health--;
                    setTimeout(removeMesh.bind(null, mesh), 1000);
                }));
            })
        }

        // Removing object from the game
        function removeMesh(mesh){
            mesh.dispose();
        }

        // Removing health bar
        function hitted(){
            wilhelm.play(-0.5);
            switch(health)
            {
                case 4:
                    guiTextureLife_100.setVisible(false);
                    break;
                case 3:
                    guiTextureLife_75.setVisible(false);
                    break;
                case 2:
                    guiTextureLife_50.setVisible(false);
                    break;
                case 1:
                    guiTextureLife_25.setVisible(false);
                    break;
                case 0:
                    guiTextureLife_0.setVisible(false);

                    var form = new CASTORGUI.GUIWindow("form", {x:(guisystem.getCanvasSize().width / 2 - 100), y:200 , w:200, h:200, overflow: "hidden"}, guisystem);
                    var optionsGUIText = {position: "relative", x: 10,y: 0, text: "Dead<br /><br />This supposed to be a very easy game<br /><br />You fucking noob <br />", color: "white", size: 12 };
                    var textForWindow = new CASTORGUI.GUIText("textInfo", optionsGUIText, guisystem, false);
                    form.add(textForWindow);
                    form.setVisible(true);
                    setTimeout(function(){location.reload();}, 3000);
                    canvas.dispose();
                    break;
            }
        }

        // Defining function for crosshair placement
        function setCrosshair()
        {
            var degf = player.rotation.y * 180 / Math.PI;
            var degv = camera.beta * 180 / Math.PI;
            playerx = 0.75 * Math.sin((degf-90) * Math.PI / 180) * -1;
            playerz = 0.75 * Math.cos((degf-90) * Math.PI / 180) * -1;
            camy = 3.3 * Math.sin(degv * Math.PI / 180);
            crosshair.position = player.position.add(new BABYLON.Vector3(playerx, camy, playerz));
            if(!isStart){
                click.position = crosshair.position.add(new BABYLON.Vector3(-0.001, 0, -0.001));
                torus.position = crosshair.position;
            }
        }
        // End of setCrosshair function

        scene.onDispose = function(){
            canvas.removeEventListener("pointerdown", onPointerDown);
            canvas.removeEventListener("pointerup", onPointerUp);
            canvas.removeEventListener("mousemove");
        }
    </script>
</body>
</html>